-- ===============================================
-- SCRIPTS DE OPTIMIZACIÓN PARA AZURE SQL DATABASE
-- Siguiendo estándares de Pacífico Salud
-- ===============================================

-- ✅ 1. ÍNDICES PRINCIPALES PARA LA CONSULTA DE DIAGNÓSTICOS-BENEFICIOS
-- Según nomenclatura EPS-DES-CMP-EST-BaseDeDatosAzureSQL.pdf

-- Índice principal para DiagnosticoBeneficio (tabla de relación)
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_01
ON convenio.DiagnosticoBeneficio(idBeneficio, idDiagnostico, estRegistro)
INCLUDE (fecCreacionSistema);

-- Índice adicional para DiagnosticoBeneficio por diagnóstico
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_02
ON convenio.DiagnosticoBeneficio(idDiagnostico, estRegistro)
INCLUDE (idBeneficio, fecCreacionSistema);

-- Índice principal para Diagnostico
CREATE NONCLUSTERED INDEX IX_Diagnostico_01
ON convenio.Diagnostico(estRegistro, codSistema)
INCLUDE (idDiagnostico, codDiagnostico, descripcionDiagnostico, desTipDiagnostico,
codGrupoDiagnostico, fecCreacionSistema, codDiagnosticoCie10);

-- Índice por código de diagnóstico
CREATE NONCLUSTERED INDEX IX_Diagnostico_02
ON convenio.Diagnostico(codDiagnostico, estRegistro)
INCLUDE (idDiagnostico, descripcionDiagnostico, codSistema);

-- Índice principal para Mae_Beneficio
CREATE NONCLUSTERED INDEX IX_Mae_Beneficio_01
ON convenio.Mae_Beneficio(estRegistro, compania, codSistema)
INCLUDE (idBeneficio, codBeneficio, descripcion, desResumida, codGrupoBeneficio);

-- Índice por código de beneficio
CREATE NONCLUSTERED INDEX IX_Mae_Beneficio_02
ON convenio.Mae_Beneficio(codBeneficio, estRegistro)
INCLUDE (idBeneficio, descripcion, desResumida, compania);

-- ✅ 2. VERIFICAR ESTADÍSTICAS Y FRAGMENTACIÓN
-- Actualizar estadísticas para mejorar el plan de ejecución
UPDATE STATISTICS convenio.DiagnosticoBeneficio WITH FULLSCAN;
UPDATE STATISTICS convenio.Diagnostico WITH FULLSCAN;
UPDATE STATISTICS convenio.Mae_Beneficio WITH FULLSCAN;

-- ✅ 3. VERIFICAR FRAGMENTACIÓN DE ÍNDICES
SELECT
OBJECT_NAME(ips.object_id) AS TableName,
i.name AS IndexName,
ips.index_type_desc,
ips.avg_fragmentation_in_percent,
ips.page_count,
CASE
WHEN ips.avg_fragmentation_in_percent > 30 THEN 'REBUILD RECOMENDADO'
WHEN ips.avg_fragmentation_in_percent > 10 THEN 'REORGANIZE RECOMENDADO'
ELSE 'OK'
END AS Recomendacion
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'DETAILED') ips
INNER JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id
WHERE ips.avg_fragmentation_in_percent > 5
AND ips.page_count > 1000
AND OBJECT_NAME(ips.object_id) IN ('DiagnosticoBeneficio', 'Diagnostico', 'Mae_Beneficio')
ORDER BY ips.avg_fragmentation_in_percent DESC;

-- ✅ 4. MANTENIMIENTO DE ÍNDICES (Ejecutar según necesidad)
-- REORGANIZE para fragmentación moderada (10-30%)
ALTER INDEX IX_DiagnosticoBeneficio_01 ON convenio.DiagnosticoBeneficio REORGANIZE;
ALTER INDEX IX_Diagnostico_01 ON convenio.Diagnostico REORGANIZE;
ALTER INDEX IX_Mae_Beneficio_01 ON convenio.Mae_Beneficio REORGANIZE;

-- REBUILD para fragmentación alta (>30%) - USAR CON CUIDADO EN PRODUCCIÓN
-- ALTER INDEX IX_DiagnosticoBeneficio_01 ON convenio.DiagnosticoBeneficio REBUILD WITH (ONLINE = ON);

-- ✅ 5. VERIFICAR PLANES DE EJECUCIÓN PROBLEMÁTICOS
-- Consultar planes de ejecución costosos
SELECT TOP 10
qs.execution_count,
qs.total_elapsed_time / 1000000.0 AS total_elapsed_time_seconds,
qs.total_worker_time / 1000000.0 AS total_cpu_time_seconds,
qs.total_logical_reads,
qs.total_physical_reads,
SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
((CASE qs.statement_end_offset
WHEN -1 THEN DATALENGTH(qt.text)
ELSE qs.statement_end_offset
END - qs.statement_start_offset)/2)+1) AS statement_text
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
WHERE qt.text LIKE '%DiagnosticoBeneficio%'
OR qt.text LIKE '%convenio.Diagnostico%'
OR qt.text LIKE '%Mae_Beneficio%'
ORDER BY qs.total_elapsed_time DESC;

-- ✅ 6. VERIFICAR ÍNDICES FALTANTES
SELECT
migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) AS improvement_measure,
'CREATE INDEX [missing_index_' + CONVERT(varchar, mig.index_group_handle) + '_' + CONVERT(varchar, mid.index_handle) + ']'
+ ' ON ' + mid.statement + ' (' + ISNULL(mid.equality_columns,'')
+ CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ',' ELSE '' END
+ ISNULL(mid.inequality_columns, '') + ')'
+ ISNULL(' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,
migs.user_seeks,
migs.user_scans,
migs.avg_total_user_cost,
migs.avg_user_impact
FROM sys.dm_db_missing_index_groups mig
INNER JOIN sys.dm_db_missing_index_group_stats migs ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handle
WHERE migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) > 10
AND (mid.statement LIKE '%DiagnosticoBeneficio%'
OR mid.statement LIKE '%Diagnostico%'
OR mid.statement LIKE '%Mae_Beneficio%')
ORDER BY improvement_measure DESC;

-- ✅ 7. CONFIGURACIÓN DE BASE DE DATOS OPTIMIZADA
-- Verificar configuración actual
SELECT
name,
value,
value_in_use,
description
FROM sys.configurations
WHERE name IN (
'max degree of parallelism',
'cost threshold for parallelism',
'optimize for ad hoc workloads'
);

-- ✅ 8. MONITOREO DE PERFORMANCE EN TIEMPO REAL
-- Consultas activas que están tardando más de 10 segundos
SELECT
r.session_id,
r.start_time,
r.status,
r.command,
r.total_elapsed_time / 1000.0 AS elapsed_seconds,
r.cpu_time / 1000.0 AS cpu_seconds,
r.logical_reads,
r.reads,
r.writes,
t.text AS query_text,
r.blocking_session_id,
r.wait_type,
r.wait_time / 1000.0 AS wait_seconds
FROM sys.dm_exec_requests r
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
WHERE r.total_elapsed_time > 10000 -- Más de 10 segundos
AND r.session_id != @@SPID
ORDER BY r.total_elapsed_time DESC;

-- ✅ 9. LIMPIEZA DE CACHE (Solo para troubleshooting en desarrollo)
-- ⚠️ NO EJECUTAR EN PRODUCCIÓN
-- DBCC FREEPROCCACHE;
-- DBCC DROPCLEANBUFFERS;

-- ✅ 10. VERIFICAR BLOQUEOS
SELECT
blocking.session_id AS blocking_session_id,
blocked.session_id AS blocked_session_id,
blocking_text.text AS blocking_text,
blocked_text.text AS blocked_text,
blocked.wait_type,
blocked.wait_time / 1000.0 AS wait_time_seconds
FROM sys.dm_exec_requests blocked
INNER JOIN sys.dm_exec_requests blocking ON blocked.blocking_session_id = blocking.session_id
CROSS APPLY sys.dm_exec_sql_text(blocking.sql_handle) blocking_text
CROSS APPLY sys.dm_exec_sql_text(blocked.sql_handle) blocked_text
WHERE blocked.blocking_session_id != 0;