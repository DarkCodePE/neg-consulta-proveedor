-- ===============================================
-- SCRIPTS DE OPTIMIZACI√ìN PARA AZURE SQL DATABASE
-- Siguiendo est√°ndares de Pac√≠fico Salud
-- ===============================================

-- ‚úÖ 1. √çNDICES PRINCIPALES PARA LA CONSULTA DE DIAGN√ìSTICOS-BENEFICIOS
-- Seg√∫n nomenclatura EPS-DES-CMP-EST-BaseDeDatosAzureSQL.pdf

-- √çndice principal para DiagnosticoBeneficio (tabla de relaci√≥n)
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_01
ON convenio.DiagnosticoBeneficio(idBeneficio, idDiagnostico, estRegistro)
INCLUDE (fecCreacionSistema);

-- √çndice adicional para DiagnosticoBeneficio por diagn√≥stico
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_02
ON convenio.DiagnosticoBeneficio(idDiagnostico, estRegistro)
INCLUDE (idBeneficio, fecCreacionSistema);

-- √çndice principal para Diagnostico
CREATE NONCLUSTERED INDEX IX_Diagnostico_01
ON convenio.Diagnostico(estRegistro, codSistema)
INCLUDE (idDiagnostico, codDiagnostico, descripcionDiagnostico, desTipDiagnostico,
codGrupoDiagnostico, fecCreacionSistema, codDiagnosticoCie10);

-- √çndice por c√≥digo de diagn√≥stico
CREATE NONCLUSTERED INDEX IX_Diagnostico_02
ON convenio.Diagnostico(codDiagnostico, estRegistro)
INCLUDE (idDiagnostico, descripcionDiagnostico, codSistema);

-- √çndice principal para Mae_Beneficio
CREATE NONCLUSTERED INDEX IX_Mae_Beneficio_01
ON convenio.Mae_Beneficio(estRegistro, compania, codSistema)
INCLUDE (idBeneficio, codBeneficio, descripcion, desResumida, codGrupoBeneficio);

-- √çndice por c√≥digo de beneficio
CREATE NONCLUSTERED INDEX IX_Mae_Beneficio_02
ON convenio.Mae_Beneficio(codBeneficio, estRegistro)
INCLUDE (idBeneficio, descripcion, desResumida, compania);

-- ‚úÖ 2. VERIFICAR ESTAD√çSTICAS Y FRAGMENTACI√ìN
-- Actualizar estad√≠sticas para mejorar el plan de ejecuci√≥n
UPDATE STATISTICS convenio.DiagnosticoBeneficio WITH FULLSCAN;
UPDATE STATISTICS convenio.Diagnostico WITH FULLSCAN;
UPDATE STATISTICS convenio.Mae_Beneficio WITH FULLSCAN;

-- ‚úÖ 3. VERIFICAR FRAGMENTACI√ìN DE √çNDICES
SELECT
OBJECT_NAME(ips.object_id) AS TableName,
i.name AS IndexName,
ips.index_type_desc,
ips.avg_fragmentation_in_percent,
ips.page_count,
CASE
WHEN ips.avg_fragmentation_in_percent > 30 THEN 'REBUILD RECOMENDADO'
WHEN ips.avg_fragmentation_in_percent > 10 THEN 'REORGANIZE RECOMENDADO'
ELSE 'OK'
END AS Recomendacion
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'DETAILED') ips
INNER JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id
WHERE ips.avg_fragmentation_in_percent > 5
AND ips.page_count > 1000
AND OBJECT_NAME(ips.object_id) IN ('DiagnosticoBeneficio', 'Diagnostico', 'Mae_Beneficio')
ORDER BY ips.avg_fragmentation_in_percent DESC;

-- ‚úÖ 4. MANTENIMIENTO DE √çNDICES (Ejecutar seg√∫n necesidad)
-- REORGANIZE para fragmentaci√≥n moderada (10-30%)
ALTER INDEX IX_DiagnosticoBeneficio_01 ON convenio.DiagnosticoBeneficio REORGANIZE;
ALTER INDEX IX_Diagnostico_01 ON convenio.Diagnostico REORGANIZE;
ALTER INDEX IX_Mae_Beneficio_01 ON convenio.Mae_Beneficio REORGANIZE;

-- REBUILD para fragmentaci√≥n alta (>30%) - USAR CON CUIDADO EN PRODUCCI√ìN
-- ALTER INDEX IX_DiagnosticoBeneficio_01 ON convenio.DiagnosticoBeneficio REBUILD WITH (ONLINE = ON);

-- ‚úÖ 5. VERIFICAR PLANES DE EJECUCI√ìN PROBLEM√ÅTICOS
-- Consultar planes de ejecuci√≥n costosos
SELECT TOP 10
qs.execution_count,
qs.total_elapsed_time / 1000000.0 AS total_elapsed_time_seconds,
qs.total_worker_time / 1000000.0 AS total_cpu_time_seconds,
qs.total_logical_reads,
qs.total_physical_reads,
SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,
((CASE qs.statement_end_offset
WHEN -1 THEN DATALENGTH(qt.text)
ELSE qs.statement_end_offset
END - qs.statement_start_offset)/2)+1) AS statement_text
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
WHERE qt.text LIKE '%DiagnosticoBeneficio%'
OR qt.text LIKE '%convenio.Diagnostico%'
OR qt.text LIKE '%Mae_Beneficio%'
ORDER BY qs.total_elapsed_time DESC;

-- ‚úÖ 6. VERIFICAR √çNDICES FALTANTES
SELECT
migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) AS improvement_measure,
'CREATE INDEX [missing_index_' + CONVERT(varchar, mig.index_group_handle) + '_' + CONVERT(varchar, mid.index_handle) + ']'
+ ' ON ' + mid.statement + ' (' + ISNULL(mid.equality_columns,'')
+ CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ',' ELSE '' END
+ ISNULL(mid.inequality_columns, '') + ')'
+ ISNULL(' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,
migs.user_seeks,
migs.user_scans,
migs.avg_total_user_cost,
migs.avg_user_impact
FROM sys.dm_db_missing_index_groups mig
INNER JOIN sys.dm_db_missing_index_group_stats migs ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handle
WHERE migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) > 10
AND (mid.statement LIKE '%DiagnosticoBeneficio%'
OR mid.statement LIKE '%Diagnostico%'
OR mid.statement LIKE '%Mae_Beneficio%')
ORDER BY improvement_measure DESC;

-- ‚úÖ 7. CONFIGURACI√ìN DE BASE DE DATOS OPTIMIZADA
-- Verificar configuraci√≥n actual
SELECT
name,
value,
value_in_use,
description
FROM sys.configurations
WHERE name IN (
'max degree of parallelism',
'cost threshold for parallelism',
'optimize for ad hoc workloads'
);

-- ‚úÖ 8. MONITOREO DE PERFORMANCE EN TIEMPO REAL
-- Consultas activas que est√°n tardando m√°s de 10 segundos
SELECT
r.session_id,
r.start_time,
r.status,
r.command,
r.total_elapsed_time / 1000.0 AS elapsed_seconds,
r.cpu_time / 1000.0 AS cpu_seconds,
r.logical_reads,
r.reads,
r.writes,
t.text AS query_text,
r.blocking_session_id,
r.wait_type,
r.wait_time / 1000.0 AS wait_seconds
FROM sys.dm_exec_requests r
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
WHERE r.total_elapsed_time > 10000 -- M√°s de 10 segundos
AND r.session_id != @@SPID
ORDER BY r.total_elapsed_time DESC;

-- ‚úÖ 9. LIMPIEZA DE CACHE (Solo para troubleshooting en desarrollo)
-- ‚ö†Ô∏è NO EJECUTAR EN PRODUCCI√ìN
-- DBCC FREEPROCCACHE;
-- DBCC DROPCLEANBUFFERS;

-- ‚úÖ 10. VERIFICAR BLOQUEOS
SELECT
blocking.session_id AS blocking_session_id,
blocked.session_id AS blocked_session_id,
blocking_text.text AS blocking_text,
blocked_text.text AS blocked_text,
blocked.wait_type,
blocked.wait_time / 1000.0 AS wait_time_seconds
FROM sys.dm_exec_requests blocked
INNER JOIN sys.dm_exec_requests blocking ON blocked.blocking_session_id = blocking.session_id
CROSS APPLY sys.dm_exec_sql_text(blocking.sql_handle) blocking_text
CROSS APPLY sys.dm_exec_sql_text(blocked.sql_handle) blocked_text
WHERE blocked.blocking_session_id != 0;







SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [convenio].[DiagnosticoBeneficio](
	[idDiagnosticoBeneficio] [nvarchar](max) NULL,
	[idDiagnostico] [nvarchar](max) NULL,
	[idBeneficio] [nvarchar](max) NULL,
	[codDiagnostico] [nvarchar](max) NULL,
	[codBeneficio] [nvarchar](max) NULL,
	[codSistema] [nvarchar](max) NULL,
	[estRegistro] [nvarchar](max) NULL,
	[codUsuarioCreadorSistema] [nvarchar](max) NULL,
	[fecCreacionsSistema] [datetime] NULL,
	[codUsuarioUpdateSistema] [nvarchar](max) NULL,
	[fecUpdateSistema] [datetime] NULL,
	[codUsuarioCreador] [nvarchar](max) NULL,
	[fecCreacion] [datetime] NULL,
	[codUsuarioUpdate] [nvarchar](max) NULL,
	[fecUpdate] [datetime] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [convenio].[Diagnostico](
	[idDiagnostico] [nvarchar](max) NULL,
	[codDiagnostico] [nvarchar](max) NULL,
	[descripcionDiagnostico] [nvarchar](max) NULL,
	[desTipDiagnostico] [nvarchar](max) NULL,
	[codGrupoDiagnostico] [nvarchar](max) NULL,
	[nivelDiagnostico] [nvarchar](max) NULL,
	[codFrecuenciaDiagnostico] [int] NULL,
	[indBeneficioCompartido] [nvarchar](max) NULL,
	[indRequiereCartaGarantia] [nvarchar](max) NULL,
	[indBeneficioExclusivo] [nvarchar](max) NULL,
	[tipoPEAS] [nvarchar](max) NULL,
	[numVersion] [int] NULL,
	[sexoExclusivo] [nvarchar](max) NULL,
	[indDiagnosticoNoRepetible] [int] NULL,
	[codSistema] [nvarchar](max) NULL,
	[fecStatus] [datetime] NULL,
	[estRegistro] [nvarchar](max) NULL,
	[codUsuarioCreadorSistema] [nvarchar](max) NULL,
	[fecCreacionSistema] [datetime] NULL,
	[codUsuarioUpdateSistema] [nvarchar](max) NULL,
	[fecUpdateSistema] [datetime] NULL,
	[codUsuarioCreador] [nvarchar](max) NULL,
	[fecCreacion] [datetime] NULL,
	[codUsuarioUpdate] [nvarchar](max) NULL,
	[fecUpdate] [datetime] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [convenio].[Mae_Beneficio](
	[idBeneficio] [nvarchar](max) NULL,
	[idGrupoBeneficio] [nvarchar](max) NULL,
	[idTipoCobertura] [nvarchar](max) NULL,
	[idSubtipoCobertura] [nvarchar](max) NULL,
	[codBeneficio] [nvarchar](max) NULL,
	[descripcion] [nvarchar](max) NULL,
	[desResumida] [nvarchar](max) NULL,
	[codGrupoBeneficio] [nvarchar](max) NULL,
	[codCobertura] [nvarchar](max) NULL,
	[subtipoCobert] [nvarchar](max) NULL,
	[estRegistro] [nvarchar](max) NULL,
	[codSistema] [nvarchar](max) NULL,
	[compania] [nvarchar](max) NULL,
	[codUsuarioCreadorSistema] [nvarchar](max) NULL,
	[fecCreacionSistema] [datetime] NULL,
	[codUsuarioUpdateSistema] [nvarchar](max) NULL,
	[fecUpdateSistema] [datetime] NULL,
	[codUsuarioCreador] [nvarchar](max) NULL,
	[fecCreacion] [datetime] NULL,
	[codUsuarioUpdate] [nvarchar](max) NULL,
	[fecUpdate] [datetime] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [convenio].[Mae_TipoCobertura](
	[idTipoCobertura] [nvarchar](max) NULL,
	[codCobertura] [nvarchar](max) NULL,
	[descripcionTipo] [nvarchar](max) NULL,
	[estRegistro] [nvarchar](max) NULL,
	[codUsuarioCreador] [nvarchar](max) NULL,
	[fecCreacion] [datetime] NULL,
	[codUsuarioUpdate] [nvarchar](max) NULL,
	[fecUpdate] [datetime] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [convenio].[Mae_TipoCobertura](
	[idTipoCobertura] [nvarchar](max) NULL,
	[codCobertura] [nvarchar](max) NULL,
	[descripcionTipo] [nvarchar](max) NULL,
	[estRegistro] [nvarchar](max) NULL,
	[codUsuarioCreador] [nvarchar](max) NULL,
	[fecCreacion] [datetime] NULL,
	[codUsuarioUpdate] [nvarchar](max) NULL,
	[fecUpdate] [datetime] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [convenio].[GrupoBeneficio](
	[idGrupoBeneficio] [nvarchar](max) NULL,
	[codGrupoBeneficio] [nvarchar](max) NULL,
	[descripcionGrupoBeneficio] [nvarchar](max) NULL,
	[codSistema] [nvarchar](max) NULL,
	[estRegistro] [nvarchar](max) NULL,
	[fecStatus] [datetime] NULL,
	[codUsuarioCreadorSistema] [nvarchar](max) NULL,
	[fecCreacionsSistema] [datetime] NULL,
	[codUsuarioUpdateSistema] [nvarchar](max) NULL,
	[fecUpdateSistema] [datetime] NULL,
	[codUsuarioCreador] [nvarchar](max) NULL,
	[fecCreacion] [datetime] NULL,
	[codUsuarioUpdate] [nvarchar](max) NULL,
	[fecUpdate] [datetime] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO


-- ===============================================
-- √çNDICES CR√çTICOS PARA RESOLVER TIMEOUT
-- ===============================================

-- ‚úÖ NOTA IMPORTANTE: Como los campos son NVARCHAR(MAX),
-- usamos LEFT() para crear √≠ndices con longitud fija

-- üö® 1. √çNDICE CR√çTICO #1: DiagnosticoBeneficio (JOIN principal)
-- Este es el m√°s importante para tu consulta
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_Critical
ON [convenio].[DiagnosticoBeneficio] (
LEFT([idBeneficio], 50),    -- Para JOIN con Mae_Beneficio
LEFT([idDiagnostico], 50),  -- Para JOIN con Diagnostico
LEFT([estRegistro], 10)     -- Para WHERE estRegistro = 'V'
)
INCLUDE (
LEFT([codDiagnostico], 50),
LEFT([codBeneficio], 50),
[fecCreacionsSistema]
);

-- üö® 2. √çNDICE CR√çTICO #2: Diagnostico (WHERE y ORDER BY)
CREATE NONCLUSTERED INDEX IX_Diagnostico_Critical
ON [convenio].[Diagnostico] (
LEFT([estRegistro], 10),        -- Para WHERE estRegistro = 'V'
LEFT([codSistema], 50),         -- Para filtro por sistema
LEFT([codDiagnostico], 50)      -- Para ORDER BY
)
INCLUDE (
LEFT([idDiagnostico], 50),
LEFT([descripcionDiagnostico], 255),
LEFT([desTipDiagnostico], 255),
LEFT([codGrupoDiagnostico], 50),
[fecCreacionSistema]
);

-- üö® 3. √çNDICE CR√çTICO #3: Mae_Beneficio (JOIN y filtros)
CREATE NONCLUSTERED INDEX IX_Mae_Beneficio_Critical
ON [convenio].[Mae_Beneficio] (
LEFT([idBeneficio], 50),    -- Para JOIN con DiagnosticoBeneficio
LEFT([estRegistro], 10),    -- Para WHERE beneficio activo
LEFT([compania], 20)        -- Para filtro por compa√±√≠a
)
INCLUDE (
LEFT([codBeneficio], 50),
LEFT([descripcion], 255),
LEFT([desResumida], 255),
LEFT([codGrupoBeneficio], 50),
LEFT([codSistema], 50)
);

-- üö® 4. √çNDICES ADICIONALES PARA OPTIMIZAR JOINS

-- Para b√∫squedas por ID de diagn√≥stico
CREATE NONCLUSTERED INDEX IX_Diagnostico_ById
ON [convenio].[Diagnostico] (LEFT([idDiagnostico], 50))
INCLUDE (LEFT([codDiagnostico], 50), LEFT([descripcionDiagnostico], 255));

-- Para b√∫squedas por ID de beneficio
CREATE NONCLUSTERED INDEX IX_Mae_Beneficio_ById
ON [convenio].[Mae_Beneficio] (LEFT([idBeneficio], 50))
INCLUDE (LEFT([codBeneficio], 50), LEFT([descripcion], 255));

-- Para la tabla de relaci√≥n por beneficio
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_ByBeneficio
ON [convenio].[DiagnosticoBeneficio] (LEFT([idBeneficio], 50), LEFT([estRegistro], 10));

-- Para la tabla de relaci√≥n por diagn√≥stico
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_ByDiagnostico
ON [convenio].[DiagnosticoBeneficio] (LEFT([idDiagnostico], 50), LEFT([estRegistro], 10));

-- ===============================================
-- VERIFICACI√ìN DE √çNDICES CREADOS
-- ===============================================

-- Verificar que los √≠ndices se crearon correctamente
SELECT
t.name AS tabla,
i.name AS indice,
i.type_desc AS tipo,
STUFF((SELECT ', ' + c.name
FROM sys.index_columns ic
INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id AND ic.is_included_column = 0
ORDER BY ic.key_ordinal
FOR XML PATH('')), 1, 2, '') AS columnas_clave,
STUFF((SELECT ', ' + c.name
FROM sys.index_columns ic
INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id AND ic.is_included_column = 1
ORDER BY ic.key_ordinal
FOR XML PATH('')), 1, 2, '') AS columnas_incluidas
FROM sys.indexes i
INNER JOIN sys.tables t ON i.object_id = t.object_id
WHERE t.name IN ('DiagnosticoBeneficio', 'Diagnostico', 'Mae_Beneficio')
AND i.name LIKE 'IX_%'
ORDER BY t.name, i.name;

-- ===============================================
-- ESTAD√çSTICAS DESPU√âS DE CREAR √çNDICES
-- ===============================================

-- Actualizar estad√≠sticas para que los √≠ndices se usen inmediatamente
UPDATE STATISTICS [convenio].[DiagnosticoBeneficio] WITH FULLSCAN;
UPDATE STATISTICS [convenio].[Diagnostico] WITH FULLSCAN;
UPDATE STATISTICS [convenio].[Mae_Beneficio] WITH FULLSCAN;

-- ===============================================
-- PROBAR IMPACTO DE LOS √çNDICES
-- ===============================================

-- Test query para verificar mejora de performance
SET STATISTICS IO ON;
SET STATISTICS TIME ON;

SELECT TOP 10
d.codDiagnostico,
d.descripcionDiagnostico,
b.codBeneficio,
b.descripcion as descripcionBeneficio
FROM [convenio].[Diagnostico] d
INNER JOIN [convenio].[DiagnosticoBeneficio] db ON LEFT(d.idDiagnostico, 50) = LEFT(db.idDiagnostico, 50)
INNER JOIN [convenio].[Mae_Beneficio] b ON LEFT(db.idBeneficio, 50) = LEFT(b.idBeneficio, 50)
WHERE LEFT(db.estRegistro, 10) = 'V'
AND LEFT(d.estRegistro, 10) = 'V'
AND LEFT(b.estRegistro, 10) = 'V'
ORDER BY d.codDiagnostico;

SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;

-- ===============================================
-- VALIDAR PLAN DE EJECUCI√ìN
-- ===============================================

-- Verificar que los √≠ndices se est√°n usando
SELECT
qs.execution_count,
qs.total_elapsed_time / 1000.0 AS total_elapsed_time_seconds,
qs.total_logical_reads,
SUBSTRING(qt.text, (qs.statement_start_offset/2)+1, 50) AS query_snippet
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
WHERE qt.text LIKE '%DiagnosticoBeneficio%'
AND qt.text LIKE '%Mae_Beneficio%'
ORDER BY qs.total_elapsed_time DESC;

-- √çndice para DiagnosticoBeneficio
CREATE NONCLUSTERED INDEX IX_DiagnosticoBeneficio_Beneficio_Estado
ON convenio.DiagnosticoBeneficio (idBeneficio, estRegistro)
INCLUDE (idDiagnostico, fecCreacionSistema);

-- √çndice para Diagnostico
CREATE NONCLUSTERED INDEX IX_Diagnostico_Estado_Sistema
ON convenio.Diagnostico (estRegistro, codSistema)
INCLUDE (codDiagnostico, descripcionDiagnostico);

-- √çndice para Mae_Beneficio
CREATE NONCLUSTERED INDEX IX_Mae_Beneficio_Compania
ON convenio.Mae_Beneficio (compania, estRegistro)
INCLUDE (codBeneficio, descripcion, desResumida);